#for each sublattice, list the sublattices in the next lower level
#no mapping for sublattices at the lowest level
multimap<int, int> slice_keys = {
	{0, {1, 2} },
	{1, {11, 12}}
}

#simulation parameters for each sublattice
map<int, ...> params = ...

#number of measurements for each sublattice
map<int, int> ms = {
	{0, 20},
	{1, ...},
	{11, ...},
	{12, ...},
	{2, ...}
}

#timeslices (list of times) included in each lowest-level sublattice
map<int, vector<int> >ts = {
	{11, {0}},
	{12, {1}},
	{2, {2, 3}}
}

#result is the type of the object computed on each sublattice (e.g. two-point operators, 4 indices)
result* sublattice_result(int key, ws*) { #ws workspace pointer
	if (slice_keys.contains(key))
		result subavg = 0;
		for(int ms = 0; ms < ms[key]; ms++)
			vector<result> subresults = {};
			for(auto sub_key : slice_keys[key])
				subresult.push_back(sublattice_result(sub_key));
			subavg += compute_subop(subresults, key, ..?)
		return subavg / ms[key]
	else {
		result subavg = 0;
		for(int ms = 0; ms < ms[key]; ms++)
			subavg += compute_subop({}, key, ...?); # compute on the sublattice corresponding to key .. compute sublattices in advance?
		return subavg / ms[key];
	}
}

#compute the operator on a given sublattice
#use lower-level sublattice results, or compute from lowest level sublattice config
#
#define here which objects are to be computed at each step (.. temporal position relative to starting point needed? use key instead?)
result* compute_subop(vector<result> v, int key) {
	....?
}



<[[T(0)][T(a)]][T(2a)T(3a)]>
subl_res(0)
	keys contains 0 ->
		subavg = 0
		for ms = 0 - ms[0]
			subres = {subl_res(1), subl_res(2)} #goto (I)
			subavg += subop(subres, 0)
		return subavg / ms[0]

#(I)
subl_res(1)
	keys contains 1 ->
		subres = {subl_res(11), subl_res(12)} #goto (II)
		subavg += subop(subres, 1)
	return subavg / ms[1]

#(II)
subl_res(11)
	keys !contains 11 ->
		subavg = 0
		for ms = 0 - ms[11]
			subavg += subop({}, 11)
		return subavg / ms[11] #leave (II)
